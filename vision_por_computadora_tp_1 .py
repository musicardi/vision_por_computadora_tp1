# -*- coding: utf-8 -*-
"""Vision_por_computadora_TP_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p7pnHS_Pp9afyF4WcId-9c1EICoagRTw

**TP1**

Parte 1 (im√°genes en /white_patch):

Implementar el algoritmo White Patch para librarnos de las diferencias de color de iluminaci√≥n.

Mostrar los resultados obtenidos y analizar las posibles fallas (si es que las hay) en el caso de White patch.

Parte 2:

Para las im√°genes img1_tp.png y img2_tp.png leerlas con OpenCV en escala de grises y visualizarlas.

Elija el n√∫mero de bins que crea conveniente y grafique su histograma, compare los histogramas entre s√≠. Explicar lo que se observa, si tuviera que entrenar un modelo de clasificaci√≥n/detecci√≥n de im√°genes, ¬øconsidera que puede ser de utilidad tomar como features a los histogramas?
"""

# ===== LIBRER√çAS =====
import cv2
import numpy as np
import os
import matplotlib.pyplot as plt

# ===== ALGORITMO WHITE PATCH =====
def white_patch_algorithm(img):
    img = img.astype(np.float32)
    max_vals = np.max(img, axis=(0, 1))  # m√°ximo de cada canal
    for c in range(3):
        if max_vals[c] > 0:
            img[:, :, c] = img[:, :, c] / max_vals[c] * 255
    return np.clip(img, 0, 255).astype(np.uint8)

# ===== RUTA DE LA CARPETA =====
carpeta = "white_patch"

# ===== PROCESAR TODAS LAS IM√ÅGENES =====
for archivo in os.listdir(carpeta):
    if archivo.lower().endswith((".png", ".jpg", ".jpeg")):
        path_in = os.path.join(carpeta, archivo)

        # Leer imagen
        img = cv2.imread(path_in)
        if img is None:
            print(f"‚ö†Ô∏è No se pudo leer: {archivo}")
            continue

        # Aplicar algoritmo
        img_wp = white_patch_algorithm(img)

        # Guardar resultado
        nombre, ext = os.path.splitext(archivo)
        path_out = os.path.join(carpeta, f"{nombre}_wp{ext}")
        cv2.imwrite(path_out, img_wp)

        # Mostrar original y corregida
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        img_wp_rgb = cv2.cvtColor(img_wp, cv2.COLOR_BGR2RGB)

        plt.figure(figsize=(8,4))
        plt.subplot(1,2,1)
        plt.imshow(img_rgb)
        plt.title(f"Original: {archivo}")
        plt.axis("off")

        plt.subplot(1,2,2)
        plt.imshow(img_wp_rgb)
        plt.title("White Patch")
        plt.axis("off")
        plt.show()

        print(f"‚úÖ Procesada {archivo} -> {nombre}_wp{ext}")

# ===== PARTE 2: HISTOGRAMAS =====
img1_path = "white_patch/img1_tp.png"
img2_path = "white_patch/img2_tp.png"

img1 = cv2.imread(img1_path, cv2.IMREAD_GRAYSCALE)
img2 = cv2.imread(img2_path, cv2.IMREAD_GRAYSCALE)

if img1 is None or img2 is None:
    print("‚ö†Ô∏è No se encontraron img1_tp.png y/o img2_tp.png, revis√° las rutas.")
else:
    # Mostrar im√°genes
    plt.figure(figsize=(10,4))
    plt.subplot(1,2,1)
    plt.imshow(img1, cmap="gray")
    plt.title("Imagen 1")
    plt.axis("off")

    plt.subplot(1,2,2)
    plt.imshow(img2, cmap="gray")
    plt.title("Imagen 2")
    plt.axis("off")
    plt.show()

    # Calcular histogramas
    bins = 32
    hist1 = cv2.calcHist([img1], [0], None, [bins], [0, 256])
    hist2 = cv2.calcHist([img2], [0], None, [bins], [0, 256])

    # Graficar histogramas (con ravel() y colores expl√≠citos)
    plt.figure(figsize=(8,4))
    plt.plot(hist1.ravel(), color='blue', label="Hist Img1")
    plt.plot(hist2.ravel(), color='orange', label="Hist Img2")
    plt.title("Comparaci√≥n de histogramas")
    plt.xlabel("Bins")
    plt.ylabel("Frecuencia")
    plt.legend()
    plt.show()


# ===== PARTE 2: HISTOGRAMAS =====
# Ajust√° la ruta donde tengas estas im√°genes
img1_path = "white_patch/img1_tp.png"
img2_path = "white_patch/img2_tp.png"

img1 = cv2.imread(img1_path, cv2.IMREAD_GRAYSCALE)
img2 = cv2.imread(img2_path, cv2.IMREAD_GRAYSCALE)

if img1 is None or img2 is None:
    print("‚ö†Ô∏è No se encontraron img1_tp.png y/o img2_tp.png, revis√° las rutas.")
else:
    # Mostrar im√°genes
    plt.figure(figsize=(10,4))
    plt.subplot(1,2,1)
    plt.imshow(img1, cmap="gray")
    plt.title("Imagen 1")
    plt.axis("off")

    plt.subplot(1,2,2)
    plt.imshow(img2, cmap="gray")
    plt.title("Imagen 2")
    plt.axis("off")
    plt.show()

    # Calcular histogramas
    bins = 256
    hist1 = cv2.calcHist([img1], [0], None, [bins], [0, 256]).flatten()
    hist2 = cv2.calcHist([img2], [0], None, [bins], [0, 256]).flatten()

    x = np.arange(bins)

    plt.figure(figsize=(10,5))
    plt.plot(x, hist1, color='blue', label="Hist Img1")
    plt.plot(x, hist2, color='orange', label="Hist Img2")
    plt.title("Comparaci√≥n de histogramas")
    plt.xlabel("Nivel de gris (0-255)")
    plt.ylabel("Frecuencia")
    plt.legend()
    plt.show()

"""# Explicaci√≥n del C√≥digo: White Patch + Histogramas

## Parte 1: Algoritmo White Patch

### Librer√≠as usadas
- `cv2` ‚Üí OpenCV, para procesamiento de im√°genes: leer, modificar y guardar im√°genes.  
- `numpy` ‚Üí manejar arreglos y operaciones matem√°ticas sobre las matrices de p√≠xeles.  
- `os` ‚Üí listar archivos de carpetas y construir rutas.  
- `matplotlib.pyplot` ‚Üí mostrar im√°genes y gr√°ficos dentro de Colab.

### Funci√≥n `white_patch_algorithm(img)`
**Objetivo:** corregir el balance de blancos usando el principio de que el p√≠xel m√°s brillante deber√≠a ser blanco.  

**Paso a paso:**
1. `img.astype(np.float32)` ‚Üí convierte la imagen a flotante para operaciones precisas.  
2. `np.max(img, axis=(0,1))` ‚Üí encuentra el valor m√°ximo de cada canal de color (B, G, R).  
3. Para cada canal:
   - Dividir todos los p√≠xeles por el valor m√°ximo.  
   - Multiplicar por 255 para escalar el canal.  
4. `np.clip(img, 0, 255)` ‚Üí asegura que los valores queden en el rango v√°lido.  
5. `astype(np.uint8)` ‚Üí vuelve la imagen a enteros para poder guardarla como PNG/JPG.  

üí° **Idea clave:** elimina dominantes de color; por ejemplo, si la imagen est√° azulada, el azul se normaliza y los otros canales se ajustan proporcionalmente.

### Procesar todas las im√°genes de una carpeta
- `os.listdir(carpeta)` ‚Üí obtiene todos los archivos de la carpeta.  
- `archivo.lower().endswith(...)` ‚Üí filtra solo im√°genes.  
- `cv2.imread(path_in)` ‚Üí carga la imagen en BGR.  
- `cv2.imwrite(path_out, img_wp)` ‚Üí guarda la imagen procesada con `_wp` agregado al nombre.  

Para mostrar la original y la corregida:
- `cv2.cvtColor(img, cv2.COLOR_BGR2RGB)` ‚Üí convierte BGR a RGB para matplotlib.  
- `plt.subplot` ‚Üí permite mostrar ambas im√°genes lado a lado.  
- `plt.axis("off")` ‚Üí oculta los ejes, mostrando solo las im√°genes.

---
## Parte 2: Histogramas

### Cargar im√°genes en escala de grises
- `cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)` ‚Üí convierte autom√°ticamente la imagen a gris.  
- Permite calcular histogramas de intensidad m√°s f√°cilmente.  
- Si la imagen no existe, se muestra un mensaje de advertencia.

### Mostrar im√°genes
- `plt.imshow(img, cmap="gray")` ‚Üí muestra la imagen en escala de grises.  
- `plt.subplot` ‚Üí permite comparar varias im√°genes lado a lado.

### Calcular histogramas
- `cv2.calcHist([img], [0], None, [bins], [0, 256])` ‚Üí calcula la frecuencia de p√≠xeles por rango de gris.  
- `[0]` ‚Üí canal √∫nico porque la imagen es gris.  
- `bins` ‚Üí n√∫mero de divisiones del rango 0-255.  
- El histograma indica cu√°ntos p√≠xeles caen en cada rango de intensidad.

### Graficar histogramas
- `plt.plot(hist.ravel())` ‚Üí grafica la frecuencia de p√≠xeles por bin.  
- `.ravel()` ‚Üí convierte el histograma a 1D, evitando problemas de visualizaci√≥n en matplotlib.  
- Colores expl√≠citos (`blue` y `orange`) permiten diferenciar las im√°genes.  
- Permite comparar visualmente el brillo y contraste de dos im√°genes.

---

## Resumen conceptual
- **White Patch:** corrige la dominante de color ajustando el p√≠xel m√°s brillante a blanco.  
- **Histogramas:** muestran la distribuci√≥n de niveles de gris, √∫til para analizar brillo y contraste entre im√°genes.





"""